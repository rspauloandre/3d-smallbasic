
SCREEN_X = 640
SCREEN_Y = 480

GraphicsWindow.Width  = SCREEN_X
GraphicsWindow.Height = SCREEN_Y

ws = SCREEN_X
hs = SCREEN_Y
sx = 0
sy = 0
ns = 0
fs = 1

a   = SCREEN_X / SCREEN_Y
fov = 60
n = 0.1
f = 48

t =  Math.Tan(Math.GetRadians(fov/2)) * n
r =  t * a    ' right  =  top * aspect
l = -r        ' left   = -right
b = -t        ' bottom = -top

TextWindow.WriteLine(t + ", " + l + ", " + r + ", " + t + ", " + b )

t =  1
r =  1
l = -1
b = -1

eye[0] = 2.0
eye[1] = 2.0
eye[2] = 8.0

at[0] = 0.0
at[1] = 0.0
at[2] = 0.0

up[0] = 0.0
up[1] = 1.0
up[2] = 0.0

' ===========================================
' Load Matrices
' ===========================================

' --------------------------------------------------------------------------
'  Matrix Rotation:
' --------------------------------------------------------------------------
angle = Math.GetRadians(0)
c = Math.Cos(angle)
s = Math.Sin(angle)

' --------------------------------------------------------------------------
MR[0][0] =  1
MR[0][1] =  0
MR[0][2] =  0
MR[0][3] =  0
MR[1][0] =  0
MR[1][1] =  c
MR[1][2] = -s
MR[1][3] =  0
MR[2][0] =  0
MR[2][1] =  s
MR[2][2] =  c
MR[2][3] =  0
MR[3][0] =  0
MR[3][1] =  0
MR[3][2] =  0
MR[3][3] =  1
' --------------------------------------------------------------------------
'MR[0][0] =  c
'MR[0][1] =  0
'MR[0][2] = -s
'MR[0][3] =  0
'MR[1][0] =  0
'MR[1][1] =  1
'MR[1][2] =  0
'MR[1][3] =  0
'MR[2][0] =  s
'MR[2][1] =  0
'MR[2][2] =  c
'MR[2][3] =  0
'MR[3][0] =  0
'MR[3][1] =  0
'MR[3][2] =  0
'MR[3][3] =  1
' --------------------------------------------------------------------------
'MR[0][0] =  c
'MR[0][1] =  s
'MR[0][2] =  0
'MR[0][3] =  0
'MR[1][0] =  s
'MR[1][1] = -c
'MR[1][2] =  0
'MR[1][3] =  0
'MR[2][0] =  0
'MR[2][1] =  0
'MR[2][2] =  1
'MR[2][3] =  0
'MR[3][0] =  0
'MR[3][1] =  0
'MR[3][2] =  0
'MR[3][3] =  1
'--------------------------------------------------------------------------

'--------------------------------------------------------------------------
'MR[0][0] =  (1 - c) * rx * rx + c
'MR[0][1] =  (1 - c) * rx * ry - s * rz
''MR[0][2] =  (1 - c) * rx * rz + s * ry
'MR[0][3] =  0
'MR[1][0] =  (1 - c) * rx * ry + s * rz
'MR[1][1] =  (1 - c) * ry * ry + c
''MR[1][2] =  (1 - c) * ry * rz - s * rz
'MR[1][3] =  0
'MR[2][0] =  (1 - c) * rx * rz - s * ry
'MR[2][1] =  (1 - c) * ry * rz + s * rx
'MR[2][2] =  (1 - c) * rz * rz + c
'MR[2][3] =  0
'MR[3][0] =  0
'MR[3][1] =  0
'MR[3][2] =  0
'MR[3][3] =  1
'--------------------------------------------------------------------------
' --------------------------------------------------------------------------
' Matrix View
' --------------------------------------------------------------------------
w[0] = eye[0] - at[0] ' z = eye - at / | eye - at |
w[1] = eye[1] - at[1]
w[2] = eye[2] - at[2]

mag = Math.SquareRoot(w[0] * w[0] + w[1] * w[1] + w[2] * w[2])
If (mag > 0) Then
  w[0] = w[0] / mag ' z
  w[1] = w[1] / mag
  w[2] = w[2] / mag
EndIf
' --------------------------------------------------------------------------
u[0] =  up[1] * w[2] - up[2] * w[1] ' x = up * z
u[1] =  up[2] * w[0] - up[0] * w[2]
u[2] =  up[0] * w[1] - up[1] * w[0]

mag = Math.SquareRoot(u[0] * u[0] + u[1] * u[1] + u[2] * u[2])
If (mag > 0) Then
  u[0] = u[0] / mag ' x
  u[1] = u[1] / mag
  u[2] = u[2] / mag
EndIf
' --------------------------------------------------------------------------
v[0] =  w[1] * u[2] - w[2] * u[1]  ' y = z * x
v[1] =  w[2] * u[0] - w[0] * u[2]
v[2] =  w[0] * u[1] - w[1] * u[0]
' --------------------------------------------------------------------------
'MR[0][0] = u[0]
'MR[0][1] = u[1]
'MR[0][2] = u[2]
'MR[0][3] = 0
'MR[1][0] = v[0]
'MR[1][1] = v[1]
'MR[1][2] = v[2]
'MR[1][3] = 0
'MR[2][0] = w[0]
'MR[2][1] = w[1]
'MR[2][2] = w[2]
'MR[2][3] = 0
'MR[3][0] = 0
'MR[3][1] = 0
'MR[3][2] = 0
'MR[3][3] = 1

'MT[0][0] = 1
'MT[0][1] = 0
'MT[0][2] = 0
'MT[0][3] = -eye[0]
'MT[1][0] = 0
'MT[1][1] = 1
'MT[1][2] = 0
'MT[1][3] = -eye[1]
'MT[2][0] = 0
'MT[2][1] = 0
'MT[2][2] = 1
'MT[2][3] = -eye[2]
'MT[3][0] = 0
'MT[3][1] = 0
'MT[3][2] = 0
'MT[3][3] = 1
' --------------------------------------------------------------------------
' Mview = Mrotate * Mtranslate
'For i = 0 to 3
'  MV[i][0] = MR[i][0] * MT[0][0] + MR[i][1] * MT[1][0] + MR[i][2] * MT[2][0] + MR[i][3] * MT[3][0]
'  MV[i][1] = MR[i][0] * MT[0][1] + MR[i][1] * MT[1][1] + MR[i][2] * MT[2][1] + MR[i][3] * MT[3][1]
'  MV[i][2] = MR[i][0] * MT[0][2] + MR[i][1] * MT[1][2] + MR[i][2] * MT[2][2] + MR[i][3] * MT[3][2]
' MV[i][3] = MR[i][0] * MT[0][3] + MR[i][1] * MT[1][3] + MR[i][2] * MT[2][3] + MR[i][3] * MT[3][3]
'EndFor
' --------------------------------------------------------------------------
MV[0][0] =  u[0]
MV[0][1] =  u[1]
MV[0][2] =  u[2]
MV[0][3] = -u[0]*eye[0]-u[1]*eye[1]-u[2]*eye[2]
MV[1][0] =  v[0]
MV[1][1] =  v[1]
MV[1][2] =  v[2]
MV[1][3] = -v[0]*eye[0]-v[1]*eye[1]-v[2]*eye[2]
MV[2][0] =  w[0]
MV[2][1] =  w[1]
MV[2][2] =  w[2]
MV[2][3] = -w[0]*eye[0]-w[1]*eye[1]-w[2]*eye[2]
MV[3][0] =  0
MV[3][1] =  0
MV[3][2] =  0
MV[3][3] =  1
' --------------------------------------------------------------------------

' --------------------------------------------------------------------------
'  Matrix Projection: 
' --------------------------------------------------------------------------
' Perspective Projection: LookAt
' --------------------------------------------------------------------------
d =  1 / Math.Tan(Math.GetRadians(fov/2))
' --------------------------------------------------------------------------
MP[0][0] =  d / a
MP[0][1] =  0
MP[0][2] =  0
MP[0][3] =  0
MP[1][0] =  0
MP[1][1] =  d
MP[1][2] =  0
MP[1][3] =  0
MP[2][0] =  0
MP[2][1] =  0
MP[2][2] = -(f + n) / (f - n)      ' (n + f) / (f - n)
MP[2][3] = -(2 * f * n) / (f - n)  ' (2 * n * f) / (n - f)
MP[3][0] =  0
MP[3][1] =  0
MP[3][2] = -1
MP[3][3] =  0
' --------------------------------------------------------------------------
' Perspective Projection - ok: Frustum
' --------------------------------------------------------------------------
'MP[0][0] =  2 * n / r - l
'MP[0][1] =  0
'MP[0][2] =  r + l / r - l
'MP[0][3] =  0
'MP[1][0] =  0
'MP[1][1] =  2 * n / t - b
'MP[1][2] =  t + b / t - b
'MP[1][3] =  0
'MP[2][0] =  0
'MP[2][1] =  0
'MP[2][2] = -(f + n) / (f - n)
'MP[2][3] = -(2 * f * n) / (f - n)
'MP[3][0] =  0
'MP[3][1] =  0
'MP[3][2] = -1
'MP[3][3] =  0
' --------------------------------------------------------------------------
' Orthographic Projection - ok: Ortho
' --------------------------------------------------------------------------
'MO[0][0] =  2 / r - l
'MO[0][1] =  0
'MO[0][2] =  0
'MO[0][3] = -(r + l / r - l)
'MO[1][0] =  0
'MO[1][1] =  2 / t - b
'MO[1][2] =  0
'MO[1][3] = -(t + b / t - b)
'MO[2][0] =  0
'MO[2][1] =  0
'MO[2][2] = -2 / (f - n)
'MO[2][3] = -((f + n) / (f - n))
'MO[3][0] =  0
'MO[3][1] =  0
'MO[3][2] =  0
'MO[3][3] =  1

' --------------------------------------------------------------------------
' T = MView * MRotate
' --------------------------------------------------------------------------
For i = 0 to 3
  T[i][0] = MV[i][0] * MR[0][0] + MV[i][1] * MR[1][0] + MV[i][2] * MR[2][0] + MV[i][3] * MR[3][0]
  T[i][1] = MV[i][0] * MR[0][1] + MV[i][1] * MR[1][1] + MV[i][2] * MR[2][1] + MV[i][3] * MR[3][1]
  T[i][2] = MV[i][0] * MR[0][2] + MV[i][1] * MR[1][2] + MV[i][2] * MR[2][2] + MV[i][3] * MR[3][2]
  T[i][3] = MV[i][0] * MR[0][3] + MV[i][1] * MR[1][3] + MV[i][2] * MR[2][3] + MV[i][3] * MR[3][3]
EndFor
' --------------------------------------------------------------------------
' M = Mprojection * T 
' --------------------------------------------------------------------------
For i = 0 to 3
  M[i][0] = MP[i][0] * T[0][0] + MP[i][1] * T[1][0] + MP[i][2] * T[2][0] + MP[i][3] * T[3][0]
  M[i][1] = MP[i][0] * T[0][1] + MP[i][1] * T[1][1] + MP[i][2] * T[2][1] + MP[i][3] * T[3][1]
  M[i][2] = MP[i][0] * T[0][2] + MP[i][1] * T[1][2] + MP[i][2] * T[2][2] + MP[i][3] * T[3][2]
  M[i][3] = MP[i][0] * T[0][3] + MP[i][1] * T[1][3] + MP[i][2] * T[2][3] + MP[i][3] * T[3][3]
EndFor


' --------------------------------------------------------------------------
' Matrix Viewport;
' --------------------------------------------------------------------------
VP[0][0] =  ws / 2
VP[0][1] =  0
VP[0][2] =  0
VP[0][3] =  sx + (ws / 2)
VP[1][0] =  0
VP[1][1] = -hs / 2
VP[1][2] =  0
VP[1][3] =  sy + (hs / 2)
VP[2][0] =  0
VP[2][1] =  0
VP[2][2] =  (fs - ns) / 2
VP[2][3] =  (fs - ns) / 2   '(ns + fs) / 2
VP[3][0] =  0
VP[3][1] =  0
VP[3][2] =  0
VP[3][3] =  1
' --------------------------------------------------------------------------

' --------------------------------------------------------------------------
' Object vertices
' --------------------------------------------------------------------------
vertices = 8

o[0][0] = -1
o[1][0] =  1
o[2][0] = -1
o[0][1] =  1
o[1][1] =  1
o[2][1] = -1
o[0][2] =  1
o[1][2] = -1
o[2][2] = -1
o[0][3] = -1
o[1][3] = -1
o[2][3] = -1
o[0][4] = -1
o[1][4] =  1
o[2][4] =  1
o[0][5] =  1
o[1][5] =  1
o[2][5] =  1
o[0][6] =  1
o[1][6] = -1
o[2][6] =  1
o[0][7] = -1
o[1][7] = -1
o[2][7] =  1
' --------------------------------------------------------------------------


For i = 0 to vertices - 1
  ' --------------------------------------------------------------------------
  '  Transformation
  ' --------------------------------------------------------------------------
  
  clip[0] = M[0][0] * o[0][i] + M[0][1] * o[1][i] + M[0][2] * o[2][i] + M[0][3]
  clip[1] = M[1][0] * o[0][i] + M[1][1] * o[1][i] + M[1][2] * o[2][i] + M[1][3]
  clip[2] = M[2][0] * o[0][i] + M[2][1] * o[1][i] + M[2][2] * o[2][i] + M[2][3] 
  clip[3] = M[3][0] * o[0][i] + M[3][1] * o[1][i] + M[3][2] * o[2][i] + M[3][3]
  
  'clip[0] = Q[0][0] * o[0][i] + Q[0][1] * o[1][i] + Q[0][2] * o[2][i] + Q[0][3]
  'clip[1] = Q[1][0] * o[0][i] + Q[1][1] * o[1][i] + Q[1][2] * o[2][i] + Q[1][3]
  'clip[2] = Q[2][0] * o[0][i] + Q[2][1] * o[1][i] + Q[2][2] * o[2][i] + Q[2][3] 
  'clip[3] = Q[3][0] * o[0][i] + Q[3][1] * o[1][i] + Q[3][2] * o[2][i] + Q[3][3]

  ndc[0] = clip[0] / clip[3]
  ndc[1] = clip[1] / clip[3]
  ndc[2] = clip[2] / clip[3]
  'ndc[3] = 1  'clip[3] / clip[3]
  
  'x[i] =        ws / 2 * ndc[0] + (sx + ws / 2)
  'y[i] =      - hs / 2 * ndc[1] + (sy + hs / 2)
  'z[i] = (fs - ns) / 2 * ndc[2] + (fs + ns) / 2
  
  x[i] = VP[0][0] * ndc[0] + VP[0][1] * ndc[1] + VP[0][2] * ndc[2] + VP[0][3]
  y[i] = VP[1][0] * ndc[0] + VP[1][1] * ndc[1] + VP[1][2] * ndc[2] + VP[1][3]
  z[i] = VP[2][0] * ndc[0] + VP[2][1] * ndc[1] + VP[2][2] * ndc[2] + VP[2][3] 
  'w[i] = VP[3][0] * ndc[0] + VP[3][1] * ndc[1] + VP[3][2] * ndc[2] + VP[3][3]

  ' -------------------------------------------------------------------------------------
  TextWindow.WriteLine(x[i] + ", " + y[i] + ", " + z[i])
  ' -------------------------------------------------------------------------------------
  
EndFor

GraphicsWIndow.PenColor = "Red"
GraphicsWindow.DrawLine(x[0], y[0], x[1], y[1])
GraphicsWindow.DrawLine(x[1], y[1], x[2], y[2])
GraphicsWindow.DrawLine(x[2], y[2], x[3], y[3])
GraphicsWindow.DrawLine(x[3], y[3], x[0], y[0])
GraphicsWIndow.PenColor = "Green"
GraphicsWindow.DrawLine(x[4], y[4], x[5], y[5])
GraphicsWindow.DrawLine(x[5], y[5], x[6], y[6])
GraphicsWindow.DrawLine(x[6], y[6], x[7], y[7])
GraphicsWindow.DrawLine(x[7], y[7], x[4], y[4])
GraphicsWIndow.PenColor = "Blue"
GraphicsWindow.DrawLine(x[0], y[0], x[4], y[4])
GraphicsWindow.DrawLine(x[1], y[1], x[5], y[5])
GraphicsWindow.DrawLine(x[2], y[2], x[6], y[6])
GraphicsWindow.DrawLine(x[3], y[3], x[7], y[7])

